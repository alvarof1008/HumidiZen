<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
  <title>HumidiZen — Intro 3D</title>

  <!-- Three.js + GSAP (CDN) -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/gsap@3.12.2/dist/gsap.min.js"></script>

  <style>
    html,body { height:100%; margin:0; font-family:Inter, Roboto, Arial, sans-serif; background:#fff; }
    #canvas-wrap { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg,#fbfaf8,#f7f6f4); }
    canvas { display:block; width:100%; height:100%; }

    /* UI overlay */
    .overlay {
      position:fixed; left:0; right:0; top:24px; display:flex; justify-content:center; pointer-events:none;
    }
    .enter-btn {
      pointer-events:auto;
      background:rgba(255,255,255,0.9);
      border:1px solid rgba(0,0,0,0.06);
      padding:10px 18px;
      border-radius:999px;
      box-shadow: 0 6px 24px rgba(16,24,40,0.06);
      cursor:pointer;
      font-weight:600;
      color:#111827;
    }
    .skip {
      position:fixed; right:18px; bottom:18px; pointer-events:auto;
      background:transparent; border:none; color:#111827; font-weight:600; opacity:0.8;
    }

    /* Loading / fade overlay */
    #fade {
      position:fixed; inset:0; background:#fff; pointer-events:none; opacity:0; transition:opacity 1s ease;
      z-index:40;
    }

    /* Mobile fallback */
    @media (max-width:760px) {
      /* hide heavy canvas on small screens if needed */
      #mobile-fallback { display:block; position:fixed; inset:0; background:#f7f6f4; z-index:45; align-items:center; justify-content:center; text-align:center; padding:24px; }
      #canvas-wrap { display:none; }
      .enter-btn { font-size:16px; padding:12px 20px; }
    }
    #mobile-fallback { display:none; }
  </style>
</head>
<body>

  <div id="canvas-wrap" aria-hidden="true"></div>

  <!-- UI -->
  <div class="overlay">
    <button id="enter" class="enter-btn" aria-label="Entrar a la tienda">Entrar a la tienda</button>
  </div>

  <div id="mobile-fallback" role="dialog" aria-hidden="true">
    <img src="data:image/svg+xml;utf8,
      <svg xmlns='http://www.w3.org/2000/svg' width='800' height='600'>
        <rect width='100%' height='100%' fill='%23f7f6f4'/>
        <text x='50%' y='45%' text-anchor='middle' font-size='28' fill='%23333' font-family='Arial'>HumidiZen</text>
        <text x='50%' y='55%' text-anchor='middle' font-size='16' fill='%23666' font-family='Arial'>Intro 3D desactivada en móvil</text>
      </svg>" alt="HumidiZen" style="max-width:80%;height:auto;margin-bottom:18px;">
    <div>
      <a id="mobile-enter" class="enter-btn" href="/collections/all">Entrar a la tienda</a>
    </div>
  </div>

  <div id="fade"></div>

<script>
/* ============================
   CONFIG
   ============================ */
const REDIRECT_URL = '/collections/all';    // cambiar si es otra ruta shopify
const AUTO_REDIRECT_AFTER_MS = 8000;        // tiempo total antes de redirigir (ms)
const CAMERA_APPROACH_DURATION = 3.8;       // segundos que dura el acercamiento

/* ============================
   Setup Three.js renderer + scene
   ============================ */
const container = document.getElementById('canvas-wrap');
const scene = new THREE.Scene();

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
container.appendChild(renderer.domElement);

/* Camera (start pulled back) */
const camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(0, 1.4, 5.5);
scene.add(camera);

/* Lights (soft warm) */
const hemi = new THREE.HemisphereLight(0xfff8f0, 0x404050, 0.8);
scene.add(hemi);
const key = new THREE.DirectionalLight(0xfff6e6, 0.6);
key.position.set(2,3,1);
scene.add(key);

/* Ground / room (simple box with subtle material) */
const room = new THREE.Mesh(
  new THREE.BoxGeometry(18, 6, 12),
  new THREE.MeshStandardMaterial({ color:0xf7f3ef, side:THREE.BackSide })
);
room.position.set(0,1.5,0);
scene.add(room);

/* Floor plane (soft shadow look) */
const floorGeo = new THREE.PlaneGeometry(10,6);
const floorMat = new THREE.MeshStandardMaterial({ color:0xf6f2ec });
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI/2;
floor.position.set(0,0.02,0);
scene.add(floor);

/* Decorative plant - simple box as placeholder */
const plant = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,1.2,8), new THREE.MeshStandardMaterial({color:0x83a17a}));
plant.position.set(-3.2,0.6,-1.8);
scene.add(plant);

/* Humidifier: stylized using primitives (cuerpo + top emisivo) */
const baseMat = new THREE.MeshStandardMaterial({
  color: 0xf7fafc,
  metalness: 0.05,
  roughness: 0.6
});
const glassMat = new THREE.MeshStandardMaterial({
  color: 0xffffff,
  metalness: 0,
  roughness: 0.15,
  envMapIntensity: 0.2
});
const base = new THREE.Mesh(new THREE.CylinderGeometry(0.55,0.55,0.22,48), baseMat);
base.position.set(0,0.18,0);
scene.add(base);

const body = new THREE.Mesh(new THREE.CylinderGeometry(0.42,0.42,0.62,48), glassMat);
body.position.set(0,0.52,0);
scene.add(body);

const top = new THREE.Mesh(new THREE.SphereGeometry(0.18,32,18), new THREE.MeshStandardMaterial({
  emissive: 0x93e0ff,
  emissiveIntensity: 0.45,
  color:0xffffff,
  roughness:0.4
}));
top.position.set(0,0.86,0);
scene.add(top);

/* Small glow on the table: invisible point light for subtle color */
const glow = new THREE.PointLight(0x93e0ff, 0.6, 3);
glow.position.set(0,0.9,0);
scene.add(glow);

/* Table */
const tableTop = new THREE.Mesh(new THREE.CylinderGeometry(1.6,1.6,0.08,48), new THREE.MeshStandardMaterial({color:0xe6d7c9, roughness:0.8}));
tableTop.position.set(0,0.02,0);
scene.add(tableTop);

/* ============================
   Smoke particles (shader) - lightweight
   ============================ */

/* We will use a point-cloud. Each particle has position, velocity, lifetime.
   A shader will draw each point as a soft circular disc with radial alpha. */

const PARTICLE_COUNT = 900; // ajustar para rendimiento
const positions = new Float32Array(PARTICLE_COUNT * 3);
const velocities = new Float32Array(PARTICLE_COUNT * 3);
const life = new Float32Array(PARTICLE_COUNT);

function rand(a,b){ return a + Math.random()*(b-a); }

for (let i=0;i<PARTICLE_COUNT;i++){
  const idx = i*3;
  // start near top of humidifier, random small offset
  positions[idx]   = rand(-0.12,0.12);
  positions[idx+1] = rand(0.9,1.05);
  positions[idx+2] = rand(-0.08,0.08);
  // initial upward velocity (y), slight horizontal drift
  velocities[idx]   = rand(-0.015,0.015);
  velocities[idx+1] = rand(0.02,0.06);
  velocities[idx+2] = rand(-0.01,0.01);
  life[i] = rand(0,1); // normalized life phase
}

const smokeGeo = new THREE.BufferGeometry();
smokeGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
smokeGeo.setAttribute('vel', new THREE.BufferAttribute(velocities,3));
smokeGeo.setAttribute('life', new THREE.BufferAttribute(life,1));

const smokeUniforms = {
  uTime: { value: 0 },
  uSize: { value: 48.0 }, // point size
  uOpacity: { value: 0.65 },
  uNoiseStrength: { value: 0.4 },
};

const smokeMaterial = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  blending: THREE.NormalBlending,
  uniforms: smokeUniforms,
  vertexShader: `
    attribute vec3 vel;
    attribute float life;
    uniform float uTime;
    varying float vLife;
    void main(){
      vLife = life;
      // compute local age
      float age = mod(uTime * 0.6 + life, 1.0);
      // base position + velocity * age * factor
      vec3 pos = position + vel * (age*70.0);
      // horizontal spread using sin for subtle swirl
      pos.x += 0.12 * sin(age*6.2831 + position.x*40.0);
      vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
      gl_PointSize = (1.0 - age) *  uSize * (300.0 / -mvPosition.z);
      gl_Position = projectionMatrix * mvPosition;
    }
  `,
  fragmentShader: `
    uniform float uOpacity;
    varying float vLife;
    void main(){
      // soft circular point
      float r = length(gl_PointCoord - vec2(0.5));
      float alpha = smoothstep(0.5, 0.0, r);
      // fade with life (older = more transparent)
      float age = mod(vLife + 0.0, 1.0);
      alpha *= (1.0 - age);
      gl_FragColor = vec4(vec3(0.92,0.94,0.96), alpha * uOpacity);
    }
  `
});

const smokePoints = new THREE.Points(smokeGeo, smokeMaterial);
scene.add(smokePoints);

/* ============================
   Camera animation (GSAP)
   ============================ */
let introPlayed = false;
function playIntroAnimation() {
  if (introPlayed) return;
  introPlayed = true;

  // initial slight rotation for life
  gsap.to(camera.rotation, { y: 0, duration: 4, ease: "sine.inOut" });

  // Camera approach: move forward into the smoke and slightly up
  gsap.to(camera.position, {
    x: 0,
    y: 1.6,
    z: 1.35,
    duration: CAMERA_APPROACH_DURATION,
    ease: "power2.inOut",
    onUpdate: () => { /* could tweak fog or particle size during transition */ }
  });

  // During the last 1s, fade white and then redirect
  gsap.to({}, {
    delay: CAMERA_APPROACH_DURATION - 0.9,
    duration: 0.9,
    onStart: () => { document.getElementById('fade').style.transition = 'opacity 0.9s ease'; },
    onUpdate: () => {},
    onComplete: () => {
      document.getElementById('fade').style.opacity = 1;
      // give a small pause then redirect
      setTimeout(() => { window.location.href = REDIRECT_URL; }, 350);
    }
  });

  // ramp particle size / opacity slightly for cinematic effect
  gsap.to(smokeUniforms.uOpacity, { value: 1.0, duration: 1.8, ease: 'sine.inOut' });
  gsap.to(smokeUniforms.uSize, { value: 88.0, duration: CAMERA_APPROACH_DURATION, ease: 'power1.out' });
}

/* ============================
   Interactions
   ============================ */
const enterBtn = document.getElementById('enter');
enterBtn.addEventListener('click', () => {
  // Play intro then redirect automatically at end
  playIntroAnimation();
  // also disable button to prevent repeated clicks
  enterBtn.disabled = true;
  enterBtn.style.opacity = 0.7;
});

// skip button (no animation): immediate redirect
const skipBtn = document.createElement('button');
skipBtn.className = 'skip';
skipBtn.innerText = 'Omitir intro';
skipBtn.onclick = () => window.location.href = REDIRECT_URL;
document.body.appendChild(skipBtn);

/* Auto-play after a short delay for users who do not click */
let autoPlayTimeout = setTimeout(() => {
  playIntroAnimation();
}, Math.max(2200, AUTO_REDIRECT_AFTER_MS - 3000)); // start approaching automatically

/* ============================
   Render loop + particle update
   ============================ */
const clock = new THREE.Clock();

function animate() {
  const dt = clock.getDelta();
  smokeUniforms.uTime.value += dt;

  // Update life attribute (rotate), to keep motion continuous
  const pos = smokeGeo.attributes.position.array;
  const vel = smokeGeo.attributes.vel.array;
  const lifeAttr = smokeGeo.attributes.life.array;

  for (let i=0;i<PARTICLE_COUNT;i++){
    const idx = i*3;
    // simple physics: move by vel; add slight random lateral motion
    pos[idx]   += vel[idx] * dt * 180.0;
    pos[idx+1] += vel[idx+1] * dt * 180.0;
    pos[idx+2] += vel[idx+2] * dt * 180.0;

    // gravity-like dispersion: slow down y velocity slightly
    vel[idx+1] *= 1.0 - (0.02*dt);

    // age increment
    lifeAttr[i] += dt * 0.08;
    if (lifeAttr[i] > 1.0) {
      // respawn at top near humidifier
      lifeAttr[i] = 0.0;
      pos[idx]   = rand(-0.12,0.12);
      pos[idx+1] = rand(0.9,1.05);
      pos[idx+2] = rand(-0.08,0.08);
      vel[idx]   = rand(-0.015,0.015);
      vel[idx+1] = rand(0.02,0.06);
      vel[idx+2] = rand(-0.01,0.01);
    }
    // slowly drift outward (x,z)
    vel[idx] += Math.sin(smokeUniforms.uTime.value*0.6 + i) * 0.0002;
    vel[idx+2] += Math.cos(smokeUniforms.uTime.value*0.5 + i*0.7) * 0.00015;
  }

  smokeGeo.attributes.position.needsUpdate = true;
  smokeGeo.attributes.vel.needsUpdate = true;
  smokeGeo.attributes.life.needsUpdate = true;

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

/* ============================
   Responsive
   ============================ */
window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});

/* ============================
   Mobile fallback detection
   ============================ */
function isLowPerfDevice() {
  const ua = navigator.userAgent || '';
  // cheap heuristic - phone or low device memory
  if (/Mobi|Android|iPhone|iPad/i.test(ua)) return true;
  if (navigator.deviceMemory && navigator.deviceMemory < 2) return true;
  return false;
}
if (isLowPerfDevice()) {
  // show fallback view
  document.getElementById('canvas-wrap').style.display = 'none';
  document.getElementById('mobile-fallback').style.display = 'flex';
  // cancel auto redirect for safety (user will click)
  clearTimeout(autoPlayTimeout);
  // hide skip button for simplicity
  skipBtn.style.display = 'none';
}

/* Accessibility: allow Enter key to start */
window.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') enterBtn.click();
});
</style>
<script src="https://unpkg.com/gsap@3.12.2/dist/gsap.min.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const button = document.querySelector(".enter-btn");
    const overlay = document.querySelector(".overlay");

    if (button && overlay) {
      button.addEventListener("click", () => {
        gsap.to(overlay, {
          opacity: 0,
          duration: 1,
          onComplete: () => {
            overlay.style.display = "none";
          }
        });
      });
    }
  });
</script>

</body>
</html>
